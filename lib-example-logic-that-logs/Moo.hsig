{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
-- | Because the logic in this sub-library needs to know how to perform logging,
--   we expand the signature through signature merging, defining a HasLogger
--   typeclass and demanding that the environment has a suitable instance.
signature Moo where

import Data.Kind
import Control.Monad.Dep.Has

data D :: Type -> Type  
data E :: Type  
instance HasLogger D E
instance Has Counter D E

-- Perhaps surprisingly, typeclass definitions are allowed in signatures,
-- methods and all. The corresponding definitions in the implementation
-- modules must match exactly.
class HasLogger d e | e -> d where
    logger :: e -> Int -> String -> d ()

data Counter d = Counter { 
        askCounter :: d Int,
        incCounter :: Int -> d ()
    }

